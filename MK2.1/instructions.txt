RF Message Handling and Filtering:
---------------------------------

Use the function `getRfValidMessage(MainTaskMsg* outMsg, bool (*isValid)(const MainTaskMsg&))` in your tasks to fetch only valid and fresh messages from the queue.

- Old messages (older than 2 seconds) are skipped and deleted.
- Unwanted messages (not valid for the current phase) are skipped and deleted.
- Only valid, fresh messages are processed by your task.

Example usage:
	auto isValid = [](const MainTaskMsg& m) { return (m.channel == 0 && m.type == LONG_PRESS); };
	if (getRfValidMessage(&msg, isValid)) {
		// Handle valid message
	}

This ensures robust queue management and prevents system lockup from stale or irrelevant messages.
/*
Generic Escape Room Board Template - Instructions
===============================================

This template provides a framework for escape room projects using ESP32 with:
- RF remote control (4 buttons: RF1-RF4)
- DFPlayer Mini for audio
- 74HC595 shift register for outputs  
- PCF8574 I2C expander (available for project-specific I/O)
- Smart message routing architecture

System Architecture:
===================

Hardware Components:
- ESP32 microcontroller
- RF remote control with 4 buttons (RF1, RF2, RF3, RF4)
- DFPlayer Mini audio module (with microSD card)
- 74HC595 shift register for digital outputs
- PCF8574 I2C expander for additional I/O (8 pins available)
- Power supply and supporting components

Pin Assignments:
- RF buttons: GPIO 23, 4, 15, 25
- I2C bus: SDA=21, SCL=22 (for PCF8574 expansion)
- DFPlayer: RX=16, TX=17 (serial communication)
- Shift register: Data=5, Clock=19, Latch=18

Software Framework:
==================

Task Structure:
1. mainTask: Game coordinator and state manager
2. preparationTask: Setup and configuration phase
3. questTask: Main game/puzzle logic
4. consequenceTask: End game processing and cleanup
5. rfControllerTask: Smart message router with state-aware filtering

Game States:
- STATE_IDLE: System ready, waiting for start
- STATE_PREPARATION: Setup and configuration
- STATE_QUEST: Main game/puzzle phase
- STATE_CONSEQUENCE: End game processing

Message Routing:
- RF messages are filtered based on current game state
- Each task has its own message queue
- Prevents unwanted button presses from causing issues
- Emergency restart available via RF4 long press

Customization Guide:
===================

For Each New Project:
1. Define project-specific message filtering in rfControllerTask
2. Implement preparation phase logic (time selection, calibration, etc.)
3. Implement quest phase logic (puzzle mechanics, win/lose conditions)
4. Implement consequence phase logic (results display, scoring, cleanup)
5. Configure shift register outputs for your hardware
6. Set up audio tracks and timing
7. Configure PCF8574 I/O for sensors/actuators as needed

Available Features:
- Laser detection system (using PCF8574)
- Audio playback with track management
- State machine coordination
- Hardware abstraction layer
- Emergency restart protocol

TODO for New Projects:
- Customize message filtering logic
- Define hardware control functions
- Implement project-specific game logic
- Configure audio tracks and timing
- Set up I/O expansion as needed
*/
